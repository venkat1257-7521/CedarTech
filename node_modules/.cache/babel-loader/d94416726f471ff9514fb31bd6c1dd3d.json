{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar prop_types_1 = require(\"prop-types\");\n\nvar isType_1 = require(\"../___utils/isType\");\n\nvar DefaultLoadIndicator_1 = __importDefault(require(\"./DefaultLoadIndicator\"));\n\nvar InfiniteLoader =\n/** @class */\nfunction (_super) {\n  __extends(InfiniteLoader, _super);\n\n  function InfiniteLoader() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      loadIndicatorContainer: null,\n      loading: false,\n      scrollingContainer: null\n    };\n    _this.loaderContainerRef = react_1.createRef(); // track the last scroll position so when new dom elements are inserted to avoid scroll jump\n\n    _this.lastScrollTop = 0;\n    _this.mounted = false; // keep track of the dom items in the list\n\n    _this.currentItemsCount = 0;\n\n    _this.getScrollingContainerChildrenCount = function () {\n      var scrollingContainer = _this.state.scrollingContainer;\n\n      if (scrollingContainer) {\n        return Math.max(0, scrollingContainer.children.length);\n      }\n\n      return 0;\n    };\n\n    _this.setupScrollingContainerEventsListener = function (removeEvent) {\n      if (removeEvent === void 0) {\n        removeEvent = false;\n      }\n\n      var scrollingContainer = _this.state.scrollingContainer;\n\n      if (scrollingContainer) {\n        ['scroll', 'mousewheel', 'touchmove'].forEach(function (event) {\n          if (removeEvent) {\n            scrollingContainer.removeEventListener(event, _this.checkIfLoadingIsNeeded, true);\n          } else {\n            scrollingContainer.addEventListener(event, _this.checkIfLoadingIsNeeded, true);\n          }\n        });\n      }\n    }; // show or hide loading indicators based on scroll position\n    // calls the \"loadMore\" function when is needed\n\n\n    _this.checkIfLoadingIsNeeded = function () {\n      if (!_this.mounted || !_this.props.hasMore || _this.state.loading) {\n        return;\n      }\n\n      var _a = _this.state,\n          scrollingContainer = _a.scrollingContainer,\n          loadIndicatorContainer = _a.loadIndicatorContainer;\n\n      if (scrollingContainer && loadIndicatorContainer) {\n        var scrollTop = scrollingContainer.scrollTop,\n            offsetTop = scrollingContainer.offsetTop,\n            offsetHeight = scrollingContainer.offsetHeight;\n        _this.lastScrollTop = scrollTop;\n        var loaderPosition = loadIndicatorContainer.offsetTop - scrollTop;\n        var startingPoint = offsetTop + offsetHeight;\n\n        if (loaderPosition <= startingPoint) {\n          _this.setState({\n            loading: true\n          }, _this.props.loadMore);\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  InfiniteLoader.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this.mounted = true;\n    var loadIndicatorContainer = this.loaderContainerRef.current;\n\n    if (loadIndicatorContainer) {\n      this.setState({\n        loadIndicatorContainer: loadIndicatorContainer,\n        scrollingContainer: loadIndicatorContainer.parentNode\n      }, function () {\n        _this.currentItemsCount = _this.getScrollingContainerChildrenCount();\n\n        _this.setupScrollingContainerEventsListener();\n      });\n    } else {\n      console.warn('FlatList: it was not possible to get container\\'s ref. ' + 'Infinite scrolling pagination will not be possible');\n    }\n  };\n\n  InfiniteLoader.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // reset scroll position to where last was\n    if (this.state.scrollingContainer) {\n      this.state.scrollingContainer.scrollTop = this.lastScrollTop;\n    } // if prev and current loading are the same is because the component updated from props change\n    // otherwise is because the component updated itself\n\n\n    if (prevState.loading === this.state.loading) {\n      this.reset();\n    }\n  };\n\n  InfiniteLoader.prototype.componentWillUnmount = function () {\n    this.setupScrollingContainerEventsListener(true);\n    this.mounted = false;\n  }; // update the loading flags and items count whether \"hasMore\" is false or list changed\n\n\n  InfiniteLoader.prototype.reset = function () {\n    if (this.state.loading) {\n      this.setState({\n        loading: false\n      });\n    }\n\n    this.checkIfLoadingIsNeeded();\n  };\n\n  InfiniteLoader.prototype.render = function () {\n    var loading = this.state.loading;\n    var _a = this.props,\n        hasMore = _a.hasMore,\n        loadingIndicator = _a.loadingIndicator,\n        loadingIndicatorPosition = _a.loadingIndicatorPosition; // do not remove the element from the dom so the ref is not broken but set it invisible enough\n\n    var styles = {\n      display: 'flex',\n      height: hasMore ? 'auto' : 0,\n      justifyContent: loadingIndicatorPosition === 'center' ? loadingIndicatorPosition : loadingIndicatorPosition === 'right' ? 'flex-end' : 'flex-start',\n      padding: hasMore ? '5px 0' : 0,\n      visibility: loading && hasMore ? 'visible' : 'hidden'\n    };\n    return react_1.default.createElement(\"div\", {\n      ref: this.loaderContainerRef,\n      className: \"__infinite-loader\",\n      style: styles\n    }, hasMore && (loadingIndicator ? isType_1.isFunction(loadingIndicator) ? loadingIndicator() : loadingIndicator : react_1.default.createElement(DefaultLoadIndicator_1.default, null)));\n  };\n\n  InfiniteLoader.propTypes = {\n    hasMore: prop_types_1.bool.isRequired,\n    loadMore: prop_types_1.func.isRequired,\n    loadingIndicator: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.node, prop_types_1.element]),\n    loadingIndicatorPosition: prop_types_1.oneOf(['left', 'center', 'right', ''])\n  };\n  InfiniteLoader.defaultProps = {\n    loadingIndicatorPosition: 'left',\n    loadingIndicator: DefaultLoadIndicator_1.default\n  };\n  return InfiniteLoader;\n}(react_1.Component);\n\nexports.default = InfiniteLoader;","map":{"version":3,"sources":["../../src/___subComponents/InfiniteLoader.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = __importStar(require(\"react\"));\nvar prop_types_1 = require(\"prop-types\");\nvar isType_1 = require(\"../___utils/isType\");\nvar DefaultLoadIndicator_1 = __importDefault(require(\"./DefaultLoadIndicator\"));\nvar InfiniteLoader = /** @class */ (function (_super) {\n    __extends(InfiniteLoader, _super);\n    function InfiniteLoader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            loadIndicatorContainer: null,\n            loading: false,\n            scrollingContainer: null\n        };\n        _this.loaderContainerRef = react_1.createRef();\n        // track the last scroll position so when new dom elements are inserted to avoid scroll jump\n        _this.lastScrollTop = 0;\n        _this.mounted = false;\n        // keep track of the dom items in the list\n        _this.currentItemsCount = 0;\n        _this.getScrollingContainerChildrenCount = function () {\n            var scrollingContainer = _this.state.scrollingContainer;\n            if (scrollingContainer) {\n                return Math.max(0, scrollingContainer.children.length);\n            }\n            return 0;\n        };\n        _this.setupScrollingContainerEventsListener = function (removeEvent) {\n            if (removeEvent === void 0) { removeEvent = false; }\n            var scrollingContainer = _this.state.scrollingContainer;\n            if (scrollingContainer) {\n                ['scroll', 'mousewheel', 'touchmove'].forEach(function (event) {\n                    if (removeEvent) {\n                        scrollingContainer.removeEventListener(event, _this.checkIfLoadingIsNeeded, true);\n                    }\n                    else {\n                        scrollingContainer.addEventListener(event, _this.checkIfLoadingIsNeeded, true);\n                    }\n                });\n            }\n        };\n        // show or hide loading indicators based on scroll position\n        // calls the \"loadMore\" function when is needed\n        _this.checkIfLoadingIsNeeded = function () {\n            if (!_this.mounted || !_this.props.hasMore || _this.state.loading) {\n                return;\n            }\n            var _a = _this.state, scrollingContainer = _a.scrollingContainer, loadIndicatorContainer = _a.loadIndicatorContainer;\n            if (scrollingContainer && loadIndicatorContainer) {\n                var scrollTop = scrollingContainer.scrollTop, offsetTop = scrollingContainer.offsetTop, offsetHeight = scrollingContainer.offsetHeight;\n                _this.lastScrollTop = scrollTop;\n                var loaderPosition = (loadIndicatorContainer.offsetTop - scrollTop);\n                var startingPoint = offsetTop + offsetHeight;\n                if (loaderPosition <= startingPoint) {\n                    _this.setState({ loading: true }, _this.props.loadMore);\n                }\n            }\n        };\n        return _this;\n    }\n    InfiniteLoader.prototype.componentDidMount = function () {\n        var _this = this;\n        this.mounted = true;\n        var loadIndicatorContainer = this.loaderContainerRef.current;\n        if (loadIndicatorContainer) {\n            this.setState({\n                loadIndicatorContainer: loadIndicatorContainer,\n                scrollingContainer: loadIndicatorContainer.parentNode\n            }, function () {\n                _this.currentItemsCount = _this.getScrollingContainerChildrenCount();\n                _this.setupScrollingContainerEventsListener();\n            });\n        }\n        else {\n            console.warn('FlatList: it was not possible to get container\\'s ref. '\n                + 'Infinite scrolling pagination will not be possible');\n        }\n    };\n    InfiniteLoader.prototype.componentDidUpdate = function (prevProps, prevState) {\n        // reset scroll position to where last was\n        if (this.state.scrollingContainer) {\n            this.state.scrollingContainer.scrollTop = this.lastScrollTop;\n        }\n        // if prev and current loading are the same is because the component updated from props change\n        // otherwise is because the component updated itself\n        if (prevState.loading === this.state.loading) {\n            this.reset();\n        }\n    };\n    InfiniteLoader.prototype.componentWillUnmount = function () {\n        this.setupScrollingContainerEventsListener(true);\n        this.mounted = false;\n    };\n    // update the loading flags and items count whether \"hasMore\" is false or list changed\n    InfiniteLoader.prototype.reset = function () {\n        if (this.state.loading) {\n            this.setState({ loading: false });\n        }\n        this.checkIfLoadingIsNeeded();\n    };\n    InfiniteLoader.prototype.render = function () {\n        var loading = this.state.loading;\n        var _a = this.props, hasMore = _a.hasMore, loadingIndicator = _a.loadingIndicator, loadingIndicatorPosition = _a.loadingIndicatorPosition;\n        // do not remove the element from the dom so the ref is not broken but set it invisible enough\n        var styles = {\n            display: 'flex',\n            height: hasMore ? 'auto' : 0,\n            justifyContent: loadingIndicatorPosition === 'center' ? loadingIndicatorPosition\n                : loadingIndicatorPosition === 'right' ? 'flex-end' : 'flex-start',\n            padding: hasMore ? '5px 0' : 0,\n            visibility: (loading && hasMore) ? 'visible' : 'hidden'\n        };\n        return (react_1.default.createElement(\"div\", { ref: this.loaderContainerRef, className: \"__infinite-loader\", style: styles }, hasMore\n            && (loadingIndicator\n                ? (isType_1.isFunction(loadingIndicator) ? loadingIndicator() : loadingIndicator)\n                : react_1.default.createElement(DefaultLoadIndicator_1.default, null))));\n    };\n    InfiniteLoader.propTypes = {\n        hasMore: prop_types_1.bool.isRequired,\n        loadMore: prop_types_1.func.isRequired,\n        loadingIndicator: prop_types_1.oneOfType([prop_types_1.func, prop_types_1.node, prop_types_1.element]),\n        loadingIndicatorPosition: prop_types_1.oneOf(['left', 'center', 'right', ''])\n    };\n    InfiniteLoader.defaultProps = {\n        loadingIndicatorPosition: 'left',\n        loadingIndicator: DefaultLoadIndicator_1.default\n    };\n    return InfiniteLoader;\n}(react_1.Component));\nexports.default = InfiniteLoader;\n//# sourceMappingURL=InfiniteLoader.js.map"]},"metadata":{},"sourceType":"script"}